{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","cats","type","value","onChange","target","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","imgs","console","log","useFetchGifs","GifExpertApp","categories","ReactDOM","render","document","querySelector"],"mappings":"2MAIaA,EAAc,SAAC,GAAqB,IAApBC,EAAmB,EAAnBA,cAGzB,EAAoCC,mBAAS,IAA7C,mBAAOC,EAAP,KAAmBC,EAAnB,KAuBA,OACI,uBAAMC,SAZW,SAACC,GAClBA,EAAEC,iBAECJ,EAAWK,OAAOC,OAAO,IAExBR,GAAc,SAAAS,GAAI,OAAIP,GAAJ,mBAAkBO,OACpCN,EAAc,MAMlB,UACI,6BAAKD,IACL,uBACIQ,KAAK,OACLC,MAAOT,EAEPU,SA5Bc,SAACP,GAOvBF,EAAcE,EAAEQ,OAAOF,c,+BChBlBG,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAIbC,EAJa,iDAImCC,UAAUH,GAJ7C,+DAKAI,MAAOF,GALP,cAKbG,EALa,gBAWEA,EAAKC,OAXP,uBAWZC,EAXY,EAWZA,KAIDC,EAAOD,EAAKE,KAAI,SAAAC,GAAO,IAAD,EAExB,MAAO,CAEHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QArBvB,kBA4BXM,GA5BW,4CAAH,sDCEPO,EAAc,SAAC,GAAoB,EAAnBJ,GAAoB,IAAhBC,EAAe,EAAfA,MAAMV,EAAS,EAATA,IAEnC,OACI,sBAAKc,UAAU,yCAAf,UACI,qBAAKC,IAAMf,EAAMgB,IAAMN,IACvB,4BAAIA,QCDHO,EAAU,SAAC,GAAkB,IAAhBnB,EAAe,EAAfA,SAIxB,ECF0B,SAACA,GAM7B,MAA0Bd,mBAAS,CAC/BqB,KAAK,GACLa,SAAS,IAFb,mBAAOC,EAAP,KAAcC,EAAd,KA4BA,OAvBAC,qBAAU,WAENxB,EAAQC,GACHwB,MAAK,SAAAC,GAGEC,QAAQC,IAAIF,GACZH,EAAS,CACLf,KAAKkB,EACLL,SAAS,SAM3B,CAACpB,IAQIqB,EDhC2BO,CAAa5B,GAAhCa,EAAb,EAAQN,KAAaa,EAArB,EAAqBA,QAsBnB,OACI,qCAAE,oBAAIJ,UAAU,qCAAd,SAAoDhB,IAKrDoB,GAAW,mBAAGJ,UAAU,mCAAb,wBACX,qBAAKA,UAAU,YAAf,SAcIH,EAAOJ,KAAM,SAAAC,GAAG,OAEb,aADA,CACC,EAAD,eAESA,GADEA,EAAIC,aEpDlBkB,EAAe,WAI1B,MAAoC3C,mBAAS,CAAC,cAA9C,mBAAO4C,EAAP,KAAmB7C,EAAnB,KAaE,OACI,qCACA,8CACA,cAAC,EAAD,CAAaA,cAAeA,IAC5B,uBASA6C,EAAWrB,KAAI,SAAAT,GAAQ,OACnB,cAAC,EAAD,CAEIA,SAAaA,GADLA,UC7BxB+B,IAASC,OAAO,cAAC,EAAD,IAAiBC,SAASC,cAAc,Y","file":"static/js/main.4b85f05f.chunk.js","sourcesContent":["import React, { useState } from 'react'\r\nimport PropTypes    from 'prop-types'\r\n\r\n//rafc\r\nexport const AddCategory = ({setCategories}) => {\r\n    //useState primero lo escribo para que lo importe de react pero uso el snipet\r\n    //puedo recibir props AddCategory = (props) y despues llamarlo props.setCategories, o recibir desestructurando como hice {setCategories}\r\n    const [inputValue, setInputValue] = useState(''); // puedo poner por ej useState(\"Hola Mundo\") y aparece escrito en el input al cargar la pág\r\n    \r\n    const handleInputChange = (e) => {\r\n        // e es el event\r\n        //a medida que voy escribiendo en el input, la fcion recibe el e y lo va agregando\r\n        // esto es solo para poder escribir en la caja de texto\r\n        // en cualquier logar donde muestre el inputValue se muestra mientras lo cambio!!\r\n        // ver en <h1>{inputValue}</h1>\r\n        //el inputValue es el último valor actualizado de lo que la persona escribió\r\n        setInputValue(e.target.value)\r\n    };\r\n    \r\n    const handleSubmit = (e) => {\r\n        e.preventDefault(); //para que no refresque toda la pág, que no haga un post\r\n //       console.log(setCategories);\r\n        if(inputValue.trim().length>2)\r\n        {\r\n            setCategories(cats =>[inputValue,...cats]);\r\n            setInputValue(''); //para que no mande dos veces lo mismo, lo vacío después de agregarlo\r\n        }\r\n        \r\n        \r\n    };\r\n    return (\r\n        <form onSubmit={handleSubmit}>\r\n            <h1>{inputValue}</h1> \r\n            <input\r\n                type=\"text\"\r\n                value={inputValue}\r\n                //tengo que manejar el onChange para porder cambiar el valor inicial.(si no no deja escribir nada en el input)\r\n                onChange={ handleInputChange }\r\n            />\r\n        </form>\r\n    )\r\n}\r\n\r\nAddCategory.propTypes = {\r\n    setCategories: PropTypes.func.isRequired\r\n    \r\n}","export const getGifs = async (category) => {\r\n    // todo esto es js actual url, resp y data\r\n    //encodeURI para quitar espacios\r\n    //console.log('22='+category);\r\n    const url =`https://api.giphy.com/v1/gifs/search?q=${ encodeURI(category)  }&limit=10&api_key=9frPDZiqGzYC3ZQbtypuWSfcMchFMdWb`\r\n    const resp = await fetch( url ); //le pido que traiga lo de la url \r\n    //resp.ok; // evalúo si la resp se hizo ok\r\n    //ver abajo la resp \r\n    // como tengo data puedo directamente desestructurar\r\n    // dentro de data (el arreglo) tengo mucha info: img, id,etc\r\n    //console.log(data);\r\n    const {data} = await resp.json(); // la infomración me la manda en formato json\r\n    //con el map, barro cada una de las imgs de la data\r\n    // el return va a retornar un obj\r\n    // con el return voy a transformar c/u de los elementos del arreglo y retornar un obj con la info que me interesa\r\n    const gifs = data.map(img =>{\r\n\r\n        return {\r\n\r\n            id: img.id,\r\n            title: img.title,\r\n            url: img.images?.downsized_medium.url\r\n            // el ? es por si no vienen la images\r\n\r\n\r\n        }\r\n    })\r\n //   console.log(gifs);\r\n    return  gifs; //mi nuevo estado son los gifs que recibo\r\n}\r\n\r\n//getGifs();  1*","import React from 'react'\r\n//puedo recibir props o lo puedo hacer con cada prop por separado\r\nexport const GifGridItem = ({id, title,url}) => {\r\n  //  console.log(id,title,url);\r\n    return (\r\n        <div className='card animate__animated animate__fadeIn'>\r\n            <img src={ url } alt={ title }/>\r\n            <p>{title}</p>\r\n        </div>\r\n    )\r\n}\r\n","//import React, { useEffect, useState } from 'react'\r\nimport React  from 'react'\r\nimport { useFetchGifs } from '../hooks/useFetchGifs';\r\n//import { getGifs } from '../helpers/getGifs';\r\nimport { GifGridItem } from './GifGridItem';\r\n\r\nexport const GifGrid = ({ category }) => {\r\n    \r\n//    const [count, setCount] = useState(0) //es solo un ejemplo para el btn\r\n  //  const state = useFetchGifs(); voy a desestructurar el obj state, solo necesito loadiing (no la data), ver línea de abajo\r\n  const { data:images, loading} = useFetchGifs(category);\r\n  //cuando pongo : (data:images) estoy renombrando la variable, para tener un nombre que me sirva\r\n    //console.log(data, loading);\r\n   /*  const [images, setImages] = useState([]); // la coleccion por default es un arreglo vacío, no lo uso más acá\r\n    //el useEffect ya no lo uso acá, está en useFetchGifs.js\r\n   useEffect(() =>{\r\n        \r\n        //getGifs retorna una promesa\r\n        getGifs(category)\r\n            .then(imgs => setImages(imgs)) \r\n            //tengo una funcioón cuyo primer argumento es mandado a la otra (setImages) como único argumento entonces lo puedo escribir así:\r\n       //     .then(setImages) \r\n\r\n        \r\n    },[category])*/\r\n    // el segundo argumento es una lista (arreglo) de dependencia\r\n    // si yo le digo que no tiene ninguna [], se va a cargar una vez\r\n    //aunque apriete muchas veces el btn de abajo\r\n    //solo se ejecuta cuando el componente es rederizado por primera vez\r\n    //pero si la category cambia quiero que lo vuelva a ejecutar, por lo tanto en vez de dejarlo vacío voy a agregar la dependencia [category]\r\n\r\n\r\n    return (\r\n        <><h3 className=\" animate__animated animate__fadeIn\">{category}</h3>\r\n        {/*loading ? 'Cargando...' : 'Fin de la carga'*/} \r\n        {/*si est'a cargando escribe Cargando, caso contrario Fin de la carga\r\n        con && solo evalúo si es true, eso lo uso cuando no me interesa el caso contrario\r\n        */}\r\n        {loading && <p className=\"animate__animated animate__flash\">Loading...</p>} \r\n         <div className=\"card-grid\">\r\n            \r\n            {//<h3>{count}</h3>\r\n            //<button onClick={() => setCount(count + 1)}>btn</button>\r\n            //*Cada vez que aprieto el botón, se ejecuta todo el componente de nuevo  y vuelve a cargar el https\r\n            // * porque detectó un cambio y hay que actualizar las referencias\r\n            // * y como getGifs (1*) está al mismo nivel lo vuelve a ejecutar\r\n            // * para que no pase, entonces en vez de useState voy a usar useEffect\r\n            // * useEffect me va a permitir ejecutar código de manera condicional\r\n            // \r\n        }\r\n             \r\n             { // el map lo puedo obtener directamente desestructurando img\r\n             //images.map( ( { id, title } )\r\n             images.map(  img  =>(\r\n                //  <li key = { id }>{ title } </li>\r\n                <GifGridItem \r\n                    key = {img.id}\r\n                     {...img}\r\n                     />  // mando cada una de las propiedades de la imagen como una propiedad  independiente\r\n                 )\r\n            )}\r\n             \r\n        </div> \r\n        </>\r\n    )\r\n}\r\n\r\n\r\n\r\n//1)en giphy developers creo el api\r\n//9frPDZiqGzYC3ZQbtypuWSfcMchFMdWb\r\n//api endpoint -> search enpoints copio la url\r\n//api.giphy.com/v1/gifs/search\r\n\r\n//2) entro a postman -> create new request (en my workspace), y pego la url de arriba con el api_key\r\n// -> send\r\n//3) para buscar algo, agrego otra key q (query)\r\n// ej q value Rick and Morty\r\n// los parametros que puedo mandar están en  https://developers.giphy.com/docs/api/endpoint#search\r\n//si no quiero muchas imgs -> limit \r\n// despues de tener la rta en postman, copio el url\r\n// me quedó así api.giphy.com/v1/gifs/search?q=Rick and Morty&limit=10&api_key=9frPDZiqGzYC3ZQbtypuWSfcMchFMdWb\r\n\r\n\r\n/*\r\ndata: (10) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]\r\nmeta: {status: 200, msg: \"OK\", response_id: \"o76hmip21bkuuex6ogbj017hntzdf9vild952e8r\"}\r\npagination: {total_count: 2066, count: 10, offset: 0}\r\n__proto__: Object\r\n﻿\r\n​\r\n*/","\r\n\r\n//import React from 'react' si no devuelve jsx no es necesario importar react\r\n//un hook es una función, es standard que comiencen con useXXX, puedo crear uno\r\n\r\nimport { useEffect, useState } from \"react\"\r\nimport { getGifs } from '../helpers/getGifs';\r\n//Crear un custom hook\r\nexport const useFetchGifs = (category) => {\r\n\r\n//estos hooks pueden tener un estado\r\n//puedo indicarle a otros componentes que lo utilicen cuándo debe  renderizarse porque algo cambia\r\n\r\n//const [state, setstate] = useState(initialState) el estado inicial va a ser un objeto, ver l'inea de abajo\r\nconst [state, setState] = useState({\r\n    data:[],\r\n    loading: true\r\n}) // cuando se utilice por primera vez el useFetchGifs, tendremos este estado  que carga por defecto\r\n//los Effect no pueden ser async\r\nuseEffect(() => {\r\n    //getGifs es una promesa\r\n    getGifs(category)\r\n        .then(imgs =>{\r\n\r\n  //          setTimeout(() => {\r\n                console.log(imgs);\r\n                setState({\r\n                    data:imgs, // imgs son los gifs que recibo como argmento en el then\r\n                    loading: false\r\n                    \r\n                });\r\n//            },3000 );\r\n            \r\n        })\r\n},[category])\r\n/*\r\nsetTimeout(() => {\r\n    setState({\r\n        data:[1,2,3,4],\r\n        loading: false\r\n    })\r\n}, 3000 ); */\r\nreturn state; // {data: [], loading:true}\r\n\r\n};","import React, { useState } from 'react';\r\nimport { AddCategory } from './components/AddCategory';\r\nimport { GifGrid } from './components/GifGrid';\r\n\r\nexport const GifExpertApp = () => {\r\n//    const categories = ['One Punch', 'Samurai X', 'Dragon Ball'];\r\n\r\n  //  const [categories, setCategories] = useState(['One Punch', 'Samurai X', 'Dragon Ball']);\r\n  const [categories, setCategories] = useState(['One Punch']);\r\n/*    \r\n    const handleAdd = () =>{\r\n        //con el setCategories cambio las prop de arr y react se entera\r\n        //no recomendable usar categories.push en este caso\r\n        // ...categories es usar el operador spread\r\n        //setCategories(['HunterX',...categories]); lo puedo agregar al inicio \r\n        setCategories([...categories,'HunterX']);\r\n        //otra manera de agregar categorias:\r\n        //cats, el primera argumento del callback es el estado anterior de la variable\r\n        //y con la fcion de flecha pasa al nuevo estado\r\n        setCategories(cats =>[...cats,'Hulk']);\r\n    } */\r\n    return (\r\n        <>\r\n        <h2>GifExpertApp</h2>\r\n        <AddCategory setCategories={setCategories}/>\r\n        <hr />\r\n        {/*<button onClick={handleAdd}>Agregar</button>*/}\r\n        {/**Cuando actualice el setCategories react renderiza el componente nuevamente y  muestra los cambios */}\r\n        {/* .map recorre el arreglo y trae la categoría y el índice*/}\r\n        \r\n        { \r\n        // li necesita un key, sino da error\r\n        //el key no tiene que ser el índice del arr y tiene que ser único\r\n        //    categories.map( category =>  (<li key={category}>{ category }</li> ))\r\n        categories.map(category =>(\r\n            <GifGrid \r\n                key = { category }\r\n                category = { category } \r\n                /> // la category que mando es la que estoy evaluando en este momento\r\n        ))\r\n        \r\n        }\r\n        \r\n        </>\r\n    )\r\n}\r\n\r\n\r\n\r\n\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nimport {GifExpertApp} from './GifExpertApp'\n\n//const divRoot = document.getElementById('root');\nReactDOM.render(<GifExpertApp />,document.querySelector('#root'));\n\n"],"sourceRoot":""}